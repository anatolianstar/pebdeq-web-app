"""
Test Runner API Routes
Handles running and managing tests through the web interface.
"""

from flask import Blueprint, request, jsonify
from app.utils.decorators import admin_required
import subprocess
import json
import os
from pathlib import Path
import threading
import time
from datetime import datetime

test_runner_bp = Blueprint('test_runner', __name__)

# Global variable to store test results
test_results = {}
test_status = {}

@test_runner_bp.route('/tests', methods=['GET'])
@admin_required
def get_available_tests():
    """Get list of available test suites."""
    try:
        test_suites = [
            {
                'id': 'auth_tests',
                'name': 'Authentication API Tests',
                'description': 'Login/logout, JWT token validation, user roles testing',
                'category': 'Backend API',
                'status': test_status.get('auth_tests', 'ready'),
                'script': 'scripts/run_auth_tests.py'
            },
            {
                'id': 'admin_tests',
                'name': 'Admin API Tests',
                'description': 'Site settings CRUD, theme settings, admin operations',
                'category': 'Backend API',
                'status': test_status.get('admin_tests', 'ready'),
                'script': 'scripts/run_admin_tests.py'
            },
            {
                'id': 'product_tests',
                'name': 'Product Management Tests',
                'description': 'Product CRUD, category management, variations testing',
                'category': 'Backend API',
                'status': test_status.get('product_tests', 'ready'),
                'script': 'scripts/run_product_tests.py'
            },
            {
                'id': 'invoice_tests',
                'name': 'Invoice System Tests',
                'description': 'PDF generation, invoice numbering, template testing',
                'category': 'Backend API',
                'status': test_status.get('invoice_tests', 'ready'),
                'script': 'scripts/run_invoice_tests.py'
            },
            {
                'id': 'order_tests',
                'name': 'Order Management Tests',
                'description': 'Order creation, status updates, order history testing',
                'category': 'Backend API',
                'status': test_status.get('order_tests', 'ready'),
                'script': 'scripts/run_order_tests.py'
            },
            {
                'id': 'theme_tests',
                'name': 'Theme System Tests',
                'description': 'Theme switching API, CSS variable updates, theme persistence',
                'category': 'Backend API',
                'status': test_status.get('theme_tests', 'ready'),
                'script': 'scripts/run_theme_tests.py'
            },
            {
                'id': 'upload_tests',
                'name': 'File Upload Tests',
                'description': 'Image upload, file validation, storage testing',
                'category': 'Backend API',
                'status': test_status.get('upload_tests', 'ready'),
                'script': 'scripts/run_upload_tests.py'
            },
            {
                'id': 'frontend_ui_tests',
                'name': 'Frontend UI Tests',
                'description': 'User interface components, forms, navigation testing',
                'category': 'Frontend UI',
                'status': test_status.get('frontend_ui_tests', 'ready'),
                'script': 'scripts/run_frontend_tests.py'
            },
            {
                'id': 'integration_tests',
                'name': 'Integration Tests',
                'description': 'Full workflow tests, user journey, system integration',
                'category': 'Integration',
                'status': test_status.get('integration_tests', 'ready'),
                'script': 'scripts/run_integration_tests.py'
            },
            {
                'id': 'performance_tests',
                'name': 'Performance Tests',
                'description': 'API response times, frontend loading speeds, optimization',
                'category': 'Performance',
                'status': test_status.get('performance_tests', 'ready'),
                'script': 'scripts/run_performance_tests.py'
            },
            {
                'id': 'security_tests',
                'name': 'Security Tests',
                'description': 'Input validation, SQL injection prevention, XSS protection',
                'category': 'Security',
                'status': test_status.get('security_tests', 'ready'),
                'script': 'scripts/run_security_tests.py'
            },
            {
                'id': 'code_integrity_tests',
                'name': 'Code Integrity Tests',
                'description': 'Duplicate code detection, quality metrics, backup validation',
                'category': 'Code Quality',
                'status': test_status.get('code_integrity_tests', 'ready'),
                'script': 'scripts/run_code_integrity_tests.py'
            }
        ]
        
        return jsonify({'test_suites': test_suites})
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@test_runner_bp.route('/tests/<test_id>/run', methods=['POST'])
@admin_required
def run_test_suite(test_id):
    """Run a specific test suite."""
    try:
        # Check if test is already running
        if test_status.get(test_id) == 'running':
            return jsonify({'error': 'Test is already running'}), 400
        
        # Set test status to running
        test_status[test_id] = 'running'
        
        # Run test in background thread
        thread = threading.Thread(target=_run_test_background, args=(test_id,))
        thread.daemon = True
        thread.start()
        
        return jsonify({
            'message': f'Test {test_id} started',
            'status': 'running'
        })
    
    except Exception as e:
        test_status[test_id] = 'error'
        return jsonify({'error': str(e)}), 500

@test_runner_bp.route('/tests/<test_id>/results', methods=['GET'])
@admin_required
def get_test_results(test_id):
    """Get results for a specific test suite."""
    try:
        current_status = test_status.get(test_id, 'ready')
        
        if test_id not in test_results:
            # Return appropriate message based on test status
            if current_status == 'running':
                return jsonify({
                    'test_id': test_id,
                    'status': current_status,
                    'message': 'Test is currently running, results not yet available'
                }), 202  # Accepted
            else:
                return jsonify({
                    'test_id': test_id,
                    'status': current_status,
                    'message': 'Test has not been run yet'
                }), 404
        
        return jsonify({
            'test_id': test_id,
            'status': current_status,
            'results': test_results[test_id]
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@test_runner_bp.route('/tests/all/run', methods=['POST'])
@admin_required
def run_all_tests():
    """Run all available test suites."""
    try:
        # Get list of test IDs that aren't currently running
        available_tests = ['auth_tests', 'admin_tests', 'product_tests', 'invoice_tests', 
                          'order_tests', 'theme_tests', 'upload_tests']
        
        running_tests = []
        for test_id in available_tests:
            if test_status.get(test_id) != 'running':
                test_status[test_id] = 'running'
                thread = threading.Thread(target=_run_test_background, args=(test_id,))
                thread.daemon = True
                thread.start()
                running_tests.append(test_id)
        
        return jsonify({
            'message': f'Started {len(running_tests)} test suites',
            'running_tests': running_tests
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@test_runner_bp.route('/tests/status', methods=['GET'])
@admin_required
def get_all_test_status():
    """Get status of all tests."""
    try:
        return jsonify({
            'test_status': test_status,
            'last_updated': datetime.now().isoformat()
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

def _run_test_background(test_id):
    """Run test in background thread."""
    try:
        # Map test IDs to script paths
        script_map = {
            'auth_tests': 'scripts/run_auth_tests.py',
            'admin_tests': 'scripts/run_admin_tests.py',
            'product_tests': 'scripts/run_product_tests.py',
            'invoice_tests': 'scripts/run_invoice_tests.py',
            'order_tests': 'scripts/run_order_tests.py',
            'theme_tests': 'scripts/run_theme_tests.py',
            'upload_tests': 'scripts/run_upload_tests.py',
            'frontend_ui_tests': 'scripts/run_frontend_tests.py',
            'integration_tests': 'scripts/run_integration_tests.py',
            'performance_tests': 'scripts/run_performance_tests.py',
            'security_tests': 'scripts/run_security_tests.py',
            'code_integrity_tests': 'scripts/run_code_integrity_tests.py'
        }
        
        script_path = script_map.get(test_id)
        if not script_path:
            test_status[test_id] = 'error'
            test_results[test_id] = {'error': 'Unknown test ID'}
            return
        
        # Get test suite directory
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        
        # Change to test suite directory
        original_dir = os.getcwd()
        os.chdir(test_suite_dir)
        
        try:
            # Set UTF-8 environment
            env = os.environ.copy()
            env['PYTHONIOENCODING'] = 'utf-8'
            env['PYTHONUTF8'] = '1'
            
            # Run the test script
            result = subprocess.run(
                ['python', script_path],
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace',  # Handle encoding errors gracefully
                timeout=300,  # 5 minute timeout
                env=env
            )
            
            # Parse results
            test_results[test_id] = {
                'exit_code': result.returncode,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'timestamp': datetime.now().isoformat(),
                'success': result.returncode == 0
            }
            
            # Try to load JSON results if available
            try:
                report_dir = test_suite_dir / 'reports' / f'{test_id}'
                if report_dir.exists():
                    # Find the latest JSON report
                    json_files = list(report_dir.glob('*_results_*.json'))
                    if json_files:
                        latest_file = max(json_files, key=lambda f: f.stat().st_mtime)
                        with open(latest_file, 'r') as f:
                            json_results = json.load(f)
                            test_results[test_id]['detailed_results'] = json_results
            except Exception as e:
                test_results[test_id]['json_error'] = str(e)
            
            test_status[test_id] = 'completed' if result.returncode == 0 else 'failed'
            
        except subprocess.TimeoutExpired:
            test_status[test_id] = 'timeout'
            test_results[test_id] = {
                'error': 'Test timed out after 5 minutes',
                'timestamp': datetime.now().isoformat(),
                'success': False
            }
        
        finally:
            os.chdir(original_dir)
    
    except Exception as e:
        test_status[test_id] = 'error'
        test_results[test_id] = {
            'error': str(e),
            'timestamp': datetime.now().isoformat(),
            'success': False
        }

@test_runner_bp.route('/tests/<test_id>/logs', methods=['GET'])
@admin_required
def get_test_logs(test_id):
    """Get detailed logs for a specific test."""
    try:
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        
        # Look for log files
        logs_dir = test_suite_dir / 'reports' / f'{test_id}'
        
        logs = {}
        if logs_dir.exists():
            # Get all log files
            for log_file in logs_dir.glob('*.txt'):
                with open(log_file, 'r') as f:
                    logs[log_file.name] = f.read()
            
            for log_file in logs_dir.glob('*.json'):
                with open(log_file, 'r') as f:
                    logs[log_file.name] = json.load(f)
        
        return jsonify({
            'test_id': test_id,
            'logs': logs
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500 

@test_runner_bp.route('/tests/code-quality/files-debug', methods=['GET'])
# @admin_required  # Temporarily disabled for debugging
def get_project_files():
    """Get list of all project files for code quality testing."""
    print("🚀 GET_PROJECT_FILES CALLED!")
    print(f"🚀 Request path: {request.path}")
    print(f"🚀 Request method: {request.method}")
    try:
        # Get test suite directory
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        scripts_dir = test_suite_dir / 'scripts'
        
        if not scripts_dir.exists():
            return jsonify({'error': f'Scripts directory not found: {scripts_dir}'}), 500
        
        # Change to scripts directory to run the command
        original_dir = os.getcwd()
        os.chdir(scripts_dir)
        
        try:
            # Check if the script exists
            script_path = scripts_dir / 'run_code_quality_tests.py'
            print(f"🔍 Script path: {script_path}")
            print(f"🔍 Script exists: {script_path.exists()}")
            
            if not script_path.exists():
                print(f"❌ Script not found!")
                return jsonify({'error': f'Script not found: {script_path}'}), 500
            
            print(f"🔍 Running command in directory: {os.getcwd()}")
            # Run the file discovery command
            result = subprocess.run(
                ['python', 'run_code_quality_tests.py', 'list'],
                capture_output=True,
                text=True,
                encoding='utf-8',
                timeout=30
            )
            
            print(f"🔍 Command return code: {result.returncode}")
            print(f"🔍 Command stdout length: {len(result.stdout)}")
            print(f"🔍 Command stderr: {result.stderr}")
            
            if result.returncode == 0:
                print("✅ Command succeeded, sending response")
                # Send raw output to frontend for parsing
                return jsonify({
                    'success': True,
                    'raw_output': result.stdout,
                    'selection_options': [
                        {'id': 0, 'name': 'All Files', 'description': 'Test all project files'},
                        {'id': 99, 'name': 'Critical Files', 'description': 'Core system files (8 files)'},
                        {'id': 98, 'name': 'Large Files', 'description': 'Files larger than 50KB'},
                        {'id': 97, 'name': 'Backend Only', 'description': 'Python files only'},
                        {'id': 96, 'name': 'Frontend Only', 'description': 'JavaScript/React files'},
                        {'id': 94, 'name': 'CSS Only', 'description': 'All CSS/Style files'},
                        {'id': 95, 'name': 'Recommended', 'description': 'Recommended test selection'}
                    ]
                })
            else:
                print(f"❌ Command failed with return code {result.returncode}")
                return jsonify({'error': f'File discovery failed: {result.stderr}'}), 500
                
        finally:
            os.chdir(original_dir)
    
    except Exception as e:
        import traceback
        print(f"🔴 EXCEPTION in get_project_files: {str(e)}")
        print(f"🔴 TRACEBACK: {traceback.format_exc()}")
        return jsonify({'error': f'Exception: {str(e)}'}), 500

@test_runner_bp.route('/tests/code-quality/run', methods=['POST'])
@admin_required
def run_code_quality_tests():
    """Run code quality tests with selected files."""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        selected_files = data.get('selected_files', [])

        
        if not selected_files:
            return jsonify({'error': 'No files selected'}), 400
        
        print(f"🔍 DEBUG - Starting test for {len(selected_files)} files: {selected_files}")
        
        # Set test status to running
        test_status['code_quality'] = 'running'
        
        # Run test in background thread
        thread = threading.Thread(target=_run_code_quality_background, args=(selected_files,))
        thread.daemon = True
        thread.start()
        
        return jsonify({
            'message': 'Code quality tests started',
            'status': 'running',
            'selected_files_count': len(selected_files),
            'testing_mode': 'individual' if len(selected_files) == 1 else 'batch'
        })
    
    except Exception as e:
        test_status['code_quality'] = 'error'
        return jsonify({'error': str(e)}), 500

@test_runner_bp.route('/tests/code-quality/backup/approve', methods=['POST'])
@admin_required
def approve_backup():
    """Approve and create backup."""
    try:
        data = request.get_json() or {}
        tested_files_info = data.get('tested_files_info', [])
        
        # Get test suite directory
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        scripts_dir = test_suite_dir / 'scripts'
        
        if not scripts_dir.exists():
            return jsonify({'error': f'Scripts directory not found: {scripts_dir}'}), 500
        
        # Change to scripts directory
        original_dir = os.getcwd()
        os.chdir(scripts_dir)
        
        try:
            # Check if the script exists
            script_path = scripts_dir / 'run_code_quality_tests.py'
            
            if not script_path.exists():
                return jsonify({'error': f'Script not found: {script_path}'}), 500
            
            # Create individual backups for each tested file
            created_backups = []
            
            if tested_files_info:
                for index, file_info in enumerate(tested_files_info):
                    file_name = file_info.get('name', 'unknown')
                    file_path = file_info.get('path', '')
                    
                    # Create individual backup description
                    description = f"Backup after testing: {file_name}"
                    
                    # Add small delay to ensure unique timestamps
                    import time
                    if index > 0:
                        time.sleep(1)  # 1 second delay between backups
                    
                    # Run backup command for individual file
                    env = dict(os.environ, 
                              WEB_BACKUP_APPROVE='1',
                              BACKUP_DESCRIPTION=description,
                              BACKUP_SINGLE_FILE='1',
                              BACKUP_FILE_NAME=file_name,
                              BACKUP_FILE_PATH=file_path)
                    
                    result = subprocess.run(
                        ['python', 'run_code_quality_tests.py', 'backup'],
                        capture_output=True,
                        text=True,
                        encoding='utf-8',
                        timeout=60,
                        input='y\n',  # Automatically approve backup
                        env=env
                    )
                    
                    if result.returncode == 0:
                        created_backups.append(file_name)
                        print(f"✅ Individual backup created for: {file_name}")
                    else:
                        print(f"Warning: Backup failed for {file_name}: {result.stderr}")
                
                # Summary result
                if created_backups:
                    result_description = f"Created {len(created_backups)} individual backups: {', '.join(created_backups[:3])}"
                    if len(created_backups) > 3:
                        result_description += f" and {len(created_backups) - 3} more"
                else:
                    result_description = "No backups created successfully"
                    result = subprocess.run(['echo', 'No successful backups'], capture_output=True, text=True)
            else:
                # Fallback to general backup
                description = "Manual backup after successful tests"
                env = dict(os.environ, 
                          WEB_BACKUP_APPROVE='1',
                          BACKUP_DESCRIPTION=description)
                
                result = subprocess.run(
                    ['python', 'run_code_quality_tests.py', 'backup'],
                    capture_output=True,
                    text=True,
                    encoding='utf-8',
                    timeout=60,
                    input='y\n',  # Automatically approve backup
                    env=env
                )
                result_description = description
            
            if result.returncode == 0:
                return jsonify({
                    'success': True,
                    'message': 'Backup created successfully',
                    'backup_output': result.stdout,
                    'description': result_description
                })
            else:
                return jsonify({
                    'success': False,
                    'message': 'Backup creation failed',
                    'error': result.stderr
                }), 500
                
        finally:
            os.chdir(original_dir)
    
    except Exception as e:
        import traceback
        print(f"🔴 EXCEPTION in approve_backup: {str(e)}")
        print(f"🔴 TRACEBACK: {traceback.format_exc()}")
        return jsonify({'error': f'Exception: {str(e)}'}), 500

@test_runner_bp.route('/tests/code-quality/backup/history', methods=['GET'])
@admin_required
def get_backup_history():
    """Get backup history from ALL backup directories."""
    try:
        # Get test suite directory
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        backups_dir = test_suite_dir / 'backups'
        
        if not backups_dir.exists():
            return jsonify({'error': f'Backups directory not found: {backups_dir}'}), 500
        
        all_backups = []
        
        # Check all backup subdirectories
        backup_subdirs = ['code_quality', 'rollback_points', 'snapshots', 'successful_states']
        
        for subdir_name in backup_subdirs:
            subdir_path = backups_dir / subdir_name
            if subdir_path.exists():
                try:
                    backup_folders = list(subdir_path.iterdir())
                    for backup_folder in backup_folders:
                        if backup_folder.is_dir():
                            # Get backup info
                            backup_info = {
                                'name': backup_folder.name,
                                'type': subdir_name,
                                'path': str(backup_folder),
                                'created': backup_folder.stat().st_mtime,
                                'size': sum(f.stat().st_size for f in backup_folder.rglob('*') if f.is_file()),
                                'description': ''
                            }
                            
                            # Try to read manifest file for description
                            manifest_file = backup_folder / 'rollback_manifest.json'
                            if manifest_file.exists():
                                try:
                                    import json
                                    with open(manifest_file, 'r', encoding='utf-8') as f:
                                        manifest = json.load(f)
                                        backup_info['description'] = manifest.get('description', '')
                                        backup_info['file_count'] = manifest.get('total_files', 0)
                                        backup_info['backup_type_detail'] = manifest.get('backup_type', '')
                                        backup_info['timestamp'] = manifest.get('timestamp', '')
                                except Exception as e:
                                    print(f"⚠️ Warning: Could not read manifest for {backup_folder.name}: {e}")
                            
                            all_backups.append(backup_info)
                            
                except Exception as e:
                    print(f"🔴 Error reading {subdir_name}: {e}")
        
        # Sort by creation time (newest first)
        all_backups.sort(key=lambda x: x['created'], reverse=True)
        
        print(f"🔍 DEBUG - Found {len(all_backups)} total backups across all directories")
        
        return jsonify({
            'success': True,
            'backups': all_backups,
            'total_count': len(all_backups),
            'by_type': {
                subdir: len([b for b in all_backups if b['type'] == subdir]) 
                for subdir in backup_subdirs
            }
        })
                
    except Exception as e:
        print(f"🔴 BACKUP HISTORY ERROR: {str(e)}")
        return jsonify({'error': f'Failed to get backup history: {str(e)}'}), 500

@test_runner_bp.route('/tests/code-quality/backup/<backup_id>', methods=['DELETE'])
@admin_required
def delete_backup(backup_id):
    """Delete a specific backup."""
    try:
        # Get test suite directory
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        rollback_dir = test_suite_dir / 'backups' / 'rollback_points' / backup_id
        
        if not rollback_dir.exists():
            return jsonify({'error': f'Backup {backup_id} not found'}), 404
        
        # Remove the entire backup directory
        import shutil
        shutil.rmtree(rollback_dir)
        
        return jsonify({
            'success': True,
            'message': f'Backup {backup_id} deleted successfully'
        })
        
    except Exception as e:
        print(f"🔴 EXCEPTION in delete_backup: {str(e)}")
        return jsonify({'error': f'Failed to delete backup: {str(e)}'}), 500

@test_runner_bp.route('/tests/code-quality/rollback', methods=['POST'])
@admin_required
def rollback_code():
    """Rollback to a previous backup."""
    try:
        data = request.get_json()
        backup_id = data.get('backup_id') if data else None
        
        # Get test suite directory
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        scripts_dir = test_suite_dir / 'scripts'
        
        # Change to scripts directory
        original_dir = os.getcwd()
        os.chdir(scripts_dir)
        
        try:
            # Run rollback command
            cmd = ['python', 'run_code_quality_tests.py', 'rollback']
            if backup_id:
                cmd.extend([backup_id])
                
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                encoding='utf-8',
                timeout=120
            )
            
            return jsonify({
                'success': result.returncode == 0,
                'message': 'Rollback completed successfully' if result.returncode == 0 else 'Rollback failed',
                'output': result.stdout,
                'error': result.stderr if result.returncode != 0 else None
            })
            
        finally:
            os.chdir(original_dir)
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@test_runner_bp.route('/tests/code-quality/rollback/bulk', methods=['POST'])
@admin_required
def bulk_rollback_code():
    """Rollback to multiple backups (applies the latest selected backup)."""
    try:
        data = request.get_json()
        backup_ids = data.get('backup_ids', []) if data else []
        
        if not backup_ids:
            return jsonify({'error': 'No backup IDs provided'}), 400
        
        # Get test suite directory
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        scripts_dir = test_suite_dir / 'scripts'
        
        # Change to scripts directory
        original_dir = os.getcwd()
        os.chdir(scripts_dir)
        
        try:
            # If multiple backups selected, find the latest one (most recent)
            if len(backup_ids) > 1:
                # Sort backup IDs by timestamp (assuming format: rollback_YYYYMMDD_HHMMSS)
                sorted_backups = sorted(backup_ids, reverse=True)  # Latest first
                backup_id = sorted_backups[0]
                print(f"🔍 Multiple backups selected, using latest: {backup_id}")
                print(f"🔍 All selected: {backup_ids}")
            else:
                backup_id = backup_ids[0]
                print(f"🔍 Single backup selected: {backup_id}")
            
            # Run rollback command
            cmd = ['python', 'run_code_quality_tests.py', 'rollback', backup_id]
                
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                encoding='utf-8',
                timeout=120
            )
            
            print(f"🔍 Rollback return code: {result.returncode}")
            print(f"🔍 Rollback stdout: {result.stdout[:500]}...")
            
            success_message = f'Backup {backup_id} restored successfully'
            if len(backup_ids) > 1:
                success_message += f' (latest from {len(backup_ids)} selected)'
            
            return jsonify({
                'success': result.returncode == 0,
                'message': success_message if result.returncode == 0 else 'Restore failed',
                'output': result.stdout,
                'error': result.stderr if result.returncode != 0 else None,
                'restored_backup': backup_id,
                'selected_count': len(backup_ids)
            })
            
        finally:
            os.chdir(original_dir)
    
    except Exception as e:
        import traceback
        print(f"🔴 EXCEPTION in bulk_rollback_code: {str(e)}")
        print(f"🔴 TRACEBACK: {traceback.format_exc()}")
        return jsonify({'error': str(e)}), 500

@test_runner_bp.route('/tests/code-quality/results', methods=['GET'])
@admin_required
def get_code_quality_results():
    """Get code quality test results."""
    try:
        current_status = test_status.get('code_quality', 'ready')
        
        if 'code_quality' not in test_results:
            if current_status == 'running':
                return jsonify({
                    'status': current_status,
                    'message': 'Tests are currently running'
                }), 202
            else:
                return jsonify({
                    'status': current_status,
                    'message': 'Tests have not been run yet'
                }), 404
        
        return jsonify({
            'status': current_status,
            'results': test_results['code_quality']
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

def parse_file_list_output(output):
    """Parse the output from file listing command."""
    lines = output.strip().split('\n')
    
    files = []
    stats = {}
    options = [
        {'id': 0, 'name': 'All Files', 'description': 'Test all project files'},
        {'id': 99, 'name': 'Critical Files', 'description': 'Core system files (8 files)'},
        {'id': 98, 'name': 'Large Files', 'description': 'Files larger than 50KB'},
        {'id': 97, 'name': 'Backend Only', 'description': 'Python files only'},
        {'id': 96, 'name': 'Frontend Only', 'description': 'JavaScript/React files'},
        {'id': 95, 'name': 'Recommended', 'description': 'Recommended test selection'}
    ]
    
    current_section = None
    file_counter = 1
    
    # Parse stats from the Turkish output
    for line in lines:
        line = line.strip()
        
        if 'PYTHON:' in line:
            current_section = 'python'
        elif 'JAVASCRIPT:' in line:
            current_section = 'javascript' 
        elif 'CSS:' in line:
            current_section = 'css'
        elif current_section:
            # Parse numbered file entry: "   67. pb_test_suite\tests\backend\test_admin_api.py (12.5KB)"
            import re
            match = re.match(r'^\s*\d+\.\s+(.+?)\s+\(([^)]+)\)$', line)
            if match:
                file_path = match.group(1).strip()
                size = match.group(2)
                
                files.append({
                    'id': file_counter,
                    'path': file_path,
                    'size': size,
                    'category': current_section,
                    'type': current_section
                })
                
                file_counter += 1
        elif 'File count:' in line:
            if current_section:
                count = line.split(':')[1].strip()
                stats[f'{current_section}_files'] = count
        elif 'Total size:' in line:
            if current_section:
                size = line.split(':')[1].strip()
                stats[f'{current_section}_size'] = size
        elif 'Total files:' in line:
            stats['total_files'] = line.split(':')[1].strip()
        elif 'Total size:' in line and 'GENERAL SUMMARY' in output[:output.index(line)]:
            stats['total_size'] = line.split(':')[1].strip()
    
    return {
        'files': files,
        'stats': stats,
        'options': options
    }

def parse_backup_history(output):
    """Parse backup history output."""
    lines = output.strip().split('\n')
    backups = []
    
    current_backup = None
    
    for line in lines:
        line = line.strip()
        
        # Look for numbered backup entries: " 1. ID: rollback_20250715_204429"
        if line and line[0].isdigit() and '. ID:' in line:
            # Save previous backup if exists
            if current_backup:
                backups.append(current_backup)
            
            # Start new backup
            backup_id = line.split('ID:')[1].strip()
            current_backup = {
                'id': backup_id,
                'date': '',
                'file_count': '',
                'description': ''
            }
        elif current_backup and 'Tarih:' in line:
            current_backup['date'] = line.split('Tarih:')[1].strip()
        elif current_backup and 'Dosya sayısı:' in line:
            current_backup['file_count'] = line.split('Dosya sayısı:')[1].strip()
        elif current_backup and 'Açıklama:' in line:
            current_backup['description'] = line.split('Açıklama:')[1].strip()
    
    # Add the last backup if exists
    if current_backup:
        backups.append(current_backup)
    
    return {'backups': backups}

def _run_code_quality_background(selected_files):
    """Run code quality tests in background thread."""
    try:
        # Get test suite directory
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        scripts_dir = test_suite_dir / 'scripts'
        
        # Change to scripts directory
        original_dir = os.getcwd()
        os.chdir(scripts_dir)
        
        try:
            # Debug: Log received files
            print(f"🔍 DEBUG - Received selected_files: {selected_files}")
            print(f"🔍 DEBUG - Type of selected_files[0]: {type(selected_files[0]) if selected_files else 'No files'}")
            
            # Prepare file selection for web interface
            if isinstance(selected_files[0], dict):
                # If files are objects with id
                file_selection = ','.join([str(f['id']) for f in selected_files])
                print(f"🔍 DEBUG - File selection from dict IDs: {file_selection}")
            else:
                # If files are just indices
                file_selection = ','.join([str(f) for f in selected_files])
                print(f"🔍 DEBUG - File selection from indices: {file_selection}")
            
            # Set environment variable for web interface mode
            env = os.environ.copy()
            env['WEB_FILE_SELECTION'] = file_selection
            env['PYTHONIOENCODING'] = 'utf-8'  # Force UTF-8 encoding
            env['PYTHONUTF8'] = '1'  # Enable UTF-8 mode in Python 3.7+
            
            print(f"🔍 DEBUG - Setting WEB_FILE_SELECTION = {file_selection}")
            print(f"🔍 DEBUG - Running in directory: {os.getcwd()}")
            
            # Run code quality tests with environment variable
            process = subprocess.run(
                ['python', 'run_code_quality_tests.py', 'test'],
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace',  # Handle encoding errors gracefully
                timeout=300,  # 5 minute timeout
                env=env
            )
            
            print(f"🔍 DEBUG - Command returncode: {process.returncode}")
            print(f"🔍 DEBUG - Stdout length: {len(process.stdout)}")
            if process.stderr:
                print(f"🔍 DEBUG - Stderr: {process.stderr}")
            
            # Parse results
            test_results['code_quality'] = {
                'exit_code': process.returncode,
                'stdout': process.stdout,
                'stderr': process.stderr,
                'timestamp': datetime.now().isoformat(),
                'success': process.returncode == 0,
                'selected_files': selected_files,
                'tests_passed': 'PASSED' in process.stdout,
                'tests_failed': 'FAILED' in process.stdout,
                'file_selection': file_selection
            }
            
            # Parse detailed results
            if process.stdout:
                test_results['code_quality']['detailed_results'] = parse_test_results(process.stdout)
            
            test_status['code_quality'] = 'completed' if process.returncode == 0 else 'failed'
            
        finally:
            os.chdir(original_dir)
    
    except Exception as e:
        print(f"🔴 EXCEPTION in _run_code_quality_background: {str(e)}")
        test_status['code_quality'] = 'error'
        test_results['code_quality'] = {
            'error': str(e),
            'timestamp': datetime.now().isoformat(),
            'success': False
        }

def parse_test_results(output):
    """Parse test results from output."""
    results = {
        'categories': [],
        'summary': {}
    }
    
    lines = output.split('\n')
    current_test = None
    
    for line in lines:
        line = line.strip()
        
        # Test category results
        if ('✅' in line or '❌' in line) or ('OK:' in line or 'ERROR:' in line):
            if ':' in line:
                parts = line.split(':', 1)
                test_name = parts[0].replace('✅', '').replace('❌', '').replace('OK', '').replace('ERROR', '').strip()
                status = 'PASSED' if ('✅' in line or 'OK:' in line) else 'FAILED'
                
                test_info = {'name': test_name, 'status': status}
                
                if len(parts) > 1:
                    test_info['details'] = parts[1].strip()
                
                results['categories'].append(test_info)
        
        # Issues count
        elif 'Issues:' in line:
            try:
                issues_count = int(line.split('Issues:')[1].strip())
                if results['categories']:
                    results['categories'][-1]['issues_count'] = issues_count
            except:
                pass
    
    return results 

@test_runner_bp.route('/tests/code-quality/changed-files', methods=['GET'])
@admin_required
def get_changed_files():
    """Get list of files that have changed since last backup."""
    try:
        # Get test suite directory
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        scripts_dir = test_suite_dir / 'scripts'
        
        if not scripts_dir.exists():
            return jsonify({'error': f'Scripts directory not found: {scripts_dir}'}), 500
        
        # Change to scripts directory
        original_dir = os.getcwd()
        os.chdir(scripts_dir)
        
        try:
            # Check if the script exists
            script_path = scripts_dir / 'run_code_quality_tests.py'
            
            if not script_path.exists():
                return jsonify({'error': f'Script not found: {script_path}'}), 500
            
            # Run command to get changed files
            result = subprocess.run(
                ['python', 'run_code_quality_tests.py', 'changed'],
                capture_output=True,
                text=True,
                encoding='utf-8',
                timeout=30
            )
            
            if result.returncode == 0:
                # Parse changed files from output
                changed_files = parse_changed_files_output(result.stdout)
                return jsonify({
                    'success': True,
                    'changed_files': changed_files,
                    'raw_output': result.stdout
                })
            else:
                return jsonify({'error': f'Failed to get changed files: {result.stderr}'}), 500
                
        finally:
            os.chdir(original_dir)
    
    except Exception as e:
        import traceback
        print(f"🔴 EXCEPTION in get_changed_files: {str(e)}")
        print(f"🔴 TRACEBACK: {traceback.format_exc()}")
        return jsonify({'error': f'Exception: {str(e)}'}), 500

@test_runner_bp.route('/tests/code-quality/changed-files/select', methods=['POST'])
@admin_required
def select_changed_files():
    """Select changed files for testing."""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        changed_file_paths = data.get('changed_files', [])
        
        if not changed_file_paths:
            return jsonify({'error': 'No files provided'}), 400
        
        # Get all project files to match paths with IDs
        # Get test suite directory
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        scripts_dir = test_suite_dir / 'scripts'
        
        if not scripts_dir.exists():
            return jsonify({'error': f'Scripts directory not found: {scripts_dir}'}), 500
        
        # Change to scripts directory
        original_dir = os.getcwd()
        os.chdir(scripts_dir)
        
        try:
            # Get all files list first
            result = subprocess.run(
                ['python', 'run_code_quality_tests.py', 'list'],
                capture_output=True,
                text=True,
                encoding='utf-8',
                timeout=30
            )
            
            if result.returncode != 0:
                return jsonify({'error': f'Failed to get file list: {result.stderr}'}), 500
            
            # Parse all files
            parsed_data = parse_file_list_output(result.stdout)
            all_files = parsed_data['files']
            
            # Match changed file paths with file IDs
            selected_file_ids = []
            matched_files = []
            
            print(f"🔍 Trying to match {len(changed_file_paths)} changed files with {len(all_files)} project files")
            
            for changed_path in changed_file_paths:
                # Normalize path separators for comparison
                normalized_changed = changed_path.replace('\\', '/').replace('//', '/').strip()
                changed_basename = normalized_changed.split('/')[-1]  # Just the filename
                
                print(f"🔍 Looking for: {normalized_changed} (basename: {changed_basename})")
                
                match_found = False
                for file_info in all_files:
                    normalized_file = file_info['path'].replace('\\', '/').replace('//', '/').strip()
                    file_basename = normalized_file.split('/')[-1]  # Just the filename
                    
                    # Multiple matching strategies
                    exact_match = normalized_file == normalized_changed
                    ends_with_match = normalized_file.endswith(normalized_changed) or normalized_changed.endswith(normalized_file)
                    basename_match = file_basename == changed_basename and changed_basename != ''
                    
                    # More flexible path matching - check if the significant parts match
                    # Split paths and compare components
                    changed_parts = [p for p in normalized_changed.split('/') if p]
                    file_parts = [p for p in normalized_file.split('/') if p]
                    
                    # Check if all changed parts exist in file parts in the same order
                    path_components_match = False
                    if len(changed_parts) > 0 and len(file_parts) > 0:
                        # Try to find a subsequence match
                        if len(changed_parts) <= len(file_parts):
                            for i in range(len(file_parts) - len(changed_parts) + 1):
                                if file_parts[i:i+len(changed_parts)] == changed_parts:
                                    path_components_match = True
                                    break
                    
                    if exact_match or ends_with_match or basename_match or path_components_match:
                        print(f"✅ MATCHED: {normalized_changed} -> {normalized_file} (ID: {file_info['id']})")
                        print(f"   Match reason: exact={exact_match}, ends_with={ends_with_match}, basename={basename_match}, components={path_components_match}")
                        
                        selected_file_ids.append(file_info['id'])
                        matched_files.append({
                            'id': file_info['id'],
                            'path': file_info['path'],
                            'size': file_info['size'],
                            'category': file_info['category'],
                            'changed_path': changed_path
                        })
                        match_found = True
                        break
                
                if not match_found:
                    print(f"❌ NO MATCH FOUND for: {normalized_changed}")
            
            print(f"🔍 Final result: {len(selected_file_ids)} matches out of {len(changed_file_paths)} changed files")
            
            return jsonify({
                'success': True,
                'selected_file_ids': selected_file_ids,
                'matched_files': matched_files,
                'total_changed': len(changed_file_paths),
                'total_matched': len(selected_file_ids)
            })
                
        finally:
            os.chdir(original_dir)
    
    except Exception as e:
        import traceback
        print(f"🔴 EXCEPTION in select_changed_files: {str(e)}")
        print(f"🔴 TRACEBACK: {traceback.format_exc()}")
        return jsonify({'error': f'Exception: {str(e)}'}), 500

@test_runner_bp.route('/tests/code-quality/backup/manual', methods=['POST'])
@admin_required
def create_manual_backup():
    """Create manual backup for selected files."""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        selected_files = data.get('selected_files', [])
        description = data.get('description', 'Manual backup')
        
        if not selected_files:
            return jsonify({'error': 'No files selected for backup'}), 400
        
        # Get test suite directory
        test_suite_dir = Path(__file__).parent.parent.parent.parent / 'pb_test_suite'
        scripts_dir = test_suite_dir / 'scripts'
        
        if not scripts_dir.exists():
            return jsonify({'error': f'Scripts directory not found: {scripts_dir}'}), 500
        
        # Change to scripts directory
        original_dir = os.getcwd()
        os.chdir(scripts_dir)
        
        try:
            # Check if the script exists
            script_path = scripts_dir / 'run_code_quality_tests.py'
            if not script_path.exists():
                return jsonify({'error': f'Script not found: {script_path}'}), 500
            
            print(f"🔍 Creating manual backup for {len(selected_files)} files")
            print(f"🔍 Description: {description}")
            
            # Set environment variables for manual backup
            env = dict(os.environ, 
                      WEB_BACKUP_APPROVE='1',
                      BACKUP_DESCRIPTION=description,
                      MANUAL_BACKUP='1',
                      SELECTED_FILES=','.join([str(f) for f in selected_files]))
            
            # Run manual backup command
            result = subprocess.run(
                ['python', 'run_code_quality_tests.py', 'backup'],
                capture_output=True,
                text=True,
                encoding='utf-8',
                timeout=120,
                input='y\n',  # Automatically approve backup
                env=env
            )
            
            print(f"🔍 Manual backup return code: {result.returncode}")
            print(f"🔍 Manual backup stdout: {result.stdout[:500]}...")
            
            if result.returncode == 0:
                return jsonify({
                    'success': True,
                    'message': 'Manual backup created successfully',
                    'output': result.stdout
                })
            else:
                return jsonify({'error': f'Manual backup failed: {result.stderr}'}), 500
                
        finally:
            os.chdir(original_dir)
    
    except Exception as e:
        import traceback
        print(f"🔴 EXCEPTION in create_manual_backup: {str(e)}")
        print(f"🔴 TRACEBACK: {traceback.format_exc()}")
        return jsonify({'error': f'Exception: {str(e)}'}), 500

def parse_changed_files_output(output):
    """Parse the output from changed files command."""
    lines = output.strip().split('\n')
    changed_files = []
    
    for line in lines:
        line = line.strip()
        
        # Look for lines that indicate changed files
        if line.startswith('M ') or line.startswith('A ') or line.startswith('D ') or line.startswith('?? '):
            # Git status format: "M  path/to/file.py"
            parts = line.split(None, 1)
            if len(parts) >= 2:
                file_path = parts[1].strip()
                status = parts[0].strip()
                
                # Map git status to readable format
                status_map = {
                    'M': 'Modified',
                    'A': 'Added', 
                    'D': 'Deleted',
                    '??': 'Untracked'
                }
                
                changed_files.append({
                    'path': file_path,
                    'status': status_map.get(status, status),
                    'git_status': status
                })
        elif line.startswith('-> '):
            # Custom format from script: "-> frontend/src/pages/TestDashboard.js [Modified]"
            file_line = line[3:].strip()  # Remove "-> "
            
            if '[' in file_line and file_line.endswith(']'):
                # Split path and status: "frontend/src/pages/TestDashboard.js [Modified]"
                parts = file_line.rsplit(' [', 1)
                if len(parts) == 2:
                    file_path = parts[0].strip()
                    status_text = parts[1][:-1].strip()  # Remove closing bracket
                    
                    # Map status text to git status format
                    status_map = {
                        'Modified': 'M',
                        'Added': 'A',
                        'Deleted': 'D',
                        'Untracked': '??'
                    }
                    
                    changed_files.append({
                        'path': file_path,
                        'status': status_text,
                        'git_status': status_map.get(status_text, 'M')
                    })
        elif '->' in line and 'changed since last backup' in output:
            # Fallback format: "-> path/to/file.py"
            file_path = line.replace('->', '').strip()
            if file_path:
                changed_files.append({
                    'path': file_path,
                    'status': 'Modified',
                    'git_status': 'M'
                })
    
    return changed_files 