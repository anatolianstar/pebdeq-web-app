from flask import Blueprint, request, jsonify, current_app
from app.models.models import CustomTheme, User
from app import db
import jwt
import os
from functools import wraps
import json
from datetime import datetime
from werkzeug.utils import secure_filename

themes_bp = Blueprint('themes', __name__)

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        token = request.headers.get('Authorization')
        
        if not token:
            return jsonify({'error': 'Token required'}), 401
        
        try:
            # Remove 'Bearer ' prefix if present
            if token.startswith('Bearer '):
                token = token[7:]
            
            data = jwt.decode(token, os.environ.get('SECRET_KEY') or 'dev-secret-key', algorithms=['HS256'])
            user = User.query.get(data['user_id'])
            
            if not user or not user.is_admin:
                return jsonify({'error': 'Admin access required'}), 403
            
            return f(*args, **kwargs)
        
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
    
    return decorated_function

def auth_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        token = request.headers.get('Authorization')
        
        if not token:
            return jsonify({'error': 'Token required'}), 401
        
        try:
            # Remove 'Bearer ' prefix if present
            if token.startswith('Bearer '):
                token = token[7:]
            
            data = jwt.decode(token, os.environ.get('SECRET_KEY') or 'dev-secret-key', algorithms=['HS256'])
            user = User.query.get(data['user_id'])
            
            if not user:
                return jsonify({'error': 'User not found'}), 404
            
            return f(user, *args, **kwargs)
        
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
    
    return decorated_function

def validate_theme_data(theme_data):
    """Validate theme data structure"""
    required_fields = ['name', 'id', 'colors', 'typography']
    errors = []
    
    for field in required_fields:
        if field not in theme_data:
            errors.append(f"Missing required field: {field}")
    
    if 'colors' in theme_data:
        required_colors = ['primary', 'secondary', 'backgroundPrimary', 'textPrimary']
        for color in required_colors:
            if color not in theme_data['colors']:
                errors.append(f"Missing required color: {color}")
    
    if 'typography' in theme_data:
        required_typography = ['fontFamilyBase', 'fontSizeBase']
        for typo in required_typography:
            if typo not in theme_data['typography']:
                errors.append(f"Missing required typography: {typo}")
    
    return errors

@themes_bp.route('/themes', methods=['GET'])
def get_themes():
    """Get all available themes"""
    try:
        themes = CustomTheme.query.filter_by(is_active=True).all()
        
        theme_list = []
        for theme in themes:
            theme_data = {
                'id': theme.id,
                'name': theme.name,
                'theme_id': theme.theme_id,
                'description': theme.description,
                'author': theme.author,
                'version': theme.version,
                'type': theme.type,
                'is_default': theme.is_default,
                'is_public': theme.is_public,
                'created_at': theme.created_at.isoformat(),
                'updated_at': theme.updated_at.isoformat(),
                'preview_colors': json.loads(theme.preview_colors) if theme.preview_colors else None,
                'download_count': theme.download_count,
                'rating': theme.rating
            }
            theme_list.append(theme_data)
        
        return jsonify({
            'themes': theme_list,
            'total': len(theme_list)
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes', methods=['POST'])
@auth_required
def create_theme(user):
    """Create a new custom theme"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # Validate theme data
        errors = validate_theme_data(data)
        if errors:
            return jsonify({'error': 'Validation failed', 'errors': errors}), 400
        
        # Check if theme ID already exists
        existing_theme = CustomTheme.query.filter_by(theme_id=data['id']).first()
        if existing_theme:
            return jsonify({'error': 'Theme ID already exists'}), 409
        
        # Create preview colors
        preview_colors = {
            'primary': data['colors'].get('primary', '#007bff'),
            'secondary': data['colors'].get('secondary', '#6c757d'),
            'background': data['colors'].get('backgroundPrimary', '#ffffff'),
            'text': data['colors'].get('textPrimary', '#212529'),
            'accent': data['colors'].get('success', '#28a745')
        }
        
        # Create new theme
        theme = CustomTheme(
            name=data['name'],
            theme_id=data['id'],
            description=data.get('description', ''),
            author=data.get('author', user.username or user.email),
            version=data.get('version', '1.0.0'),
            type=data.get('type', 'light'),
            theme_data=json.dumps(data),
            css_content=data.get('css', ''),
            preview_colors=json.dumps(preview_colors),
            creator_id=user.id,
            is_public=data.get('is_public', True),
            is_active=True
        )
        
        db.session.add(theme)
        db.session.commit()
        
        return jsonify({
            'message': 'Theme created successfully',
            'theme': {
                'id': theme.id,
                'name': theme.name,
                'theme_id': theme.theme_id,
                'description': theme.description,
                'author': theme.author,
                'version': theme.version,
                'type': theme.type,
                'preview_colors': preview_colors,
                'created_at': theme.created_at.isoformat()
            }
        }), 201
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes/<int:theme_id>', methods=['GET'])
def get_theme(theme_id):
    """Get a specific theme by ID"""
    try:
        theme = CustomTheme.query.get_or_404(theme_id)
        
        if not theme.is_active:
            return jsonify({'error': 'Theme not found'}), 404
        
        # Increment download count
        theme.download_count += 1
        db.session.commit()
        
        return jsonify({
            'theme': {
                'id': theme.id,
                'name': theme.name,
                'theme_id': theme.theme_id,
                'description': theme.description,
                'author': theme.author,
                'version': theme.version,
                'type': theme.type,
                'theme_data': json.loads(theme.theme_data),
                'css_content': theme.css_content,
                'preview_colors': json.loads(theme.preview_colors) if theme.preview_colors else None,
                'is_public': theme.is_public,
                'download_count': theme.download_count,
                'rating': theme.rating,
                'created_at': theme.created_at.isoformat(),
                'updated_at': theme.updated_at.isoformat()
            }
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes/<int:theme_id>', methods=['PUT'])
@auth_required
def update_theme(user, theme_id):
    """Update an existing theme"""
    try:
        theme = CustomTheme.query.get_or_404(theme_id)
        
        # Check if user is the creator or admin
        if theme.creator_id != user.id and not user.is_admin:
            return jsonify({'error': 'Permission denied'}), 403
        
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # Validate theme data
        errors = validate_theme_data(data)
        if errors:
            return jsonify({'error': 'Validation failed', 'errors': errors}), 400
        
        # Update theme fields
        theme.name = data.get('name', theme.name)
        theme.description = data.get('description', theme.description)
        theme.author = data.get('author', theme.author)
        theme.version = data.get('version', theme.version)
        theme.type = data.get('type', theme.type)
        theme.theme_data = json.dumps(data)
        theme.css_content = data.get('css', theme.css_content)
        theme.is_public = data.get('is_public', theme.is_public)
        theme.updated_at = datetime.utcnow()
        
        # Update preview colors
        preview_colors = {
            'primary': data['colors'].get('primary', '#007bff'),
            'secondary': data['colors'].get('secondary', '#6c757d'),
            'background': data['colors'].get('backgroundPrimary', '#ffffff'),
            'text': data['colors'].get('textPrimary', '#212529'),
            'accent': data['colors'].get('success', '#28a745')
        }
        theme.preview_colors = json.dumps(preview_colors)
        
        db.session.commit()
        
        return jsonify({
            'message': 'Theme updated successfully',
            'theme': {
                'id': theme.id,
                'name': theme.name,
                'theme_id': theme.theme_id,
                'description': theme.description,
                'author': theme.author,
                'version': theme.version,
                'type': theme.type,
                'preview_colors': preview_colors,
                'updated_at': theme.updated_at.isoformat()
            }
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes/<int:theme_id>', methods=['DELETE'])
@auth_required
def delete_theme(user, theme_id):
    """Delete a theme (soft delete)"""
    try:
        theme = CustomTheme.query.get_or_404(theme_id)
        
        # Check if user is the creator or admin
        if theme.creator_id != user.id and not user.is_admin:
            return jsonify({'error': 'Permission denied'}), 403
        
        # Don't allow deletion of default themes
        if theme.is_default:
            return jsonify({'error': 'Cannot delete default theme'}), 400
        
        # Soft delete
        theme.is_active = False
        theme.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'message': 'Theme deleted successfully'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes/<int:theme_id>/activate', methods=['POST'])
@admin_required
def activate_theme(theme_id):
    """Activate a theme (admin only)"""
    try:
        theme = CustomTheme.query.get_or_404(theme_id)
        
        theme.is_active = True
        theme.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'message': 'Theme activated successfully'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes/<int:theme_id>/deactivate', methods=['POST'])
@admin_required
def deactivate_theme(theme_id):
    """Deactivate a theme (admin only)"""
    try:
        theme = CustomTheme.query.get_or_404(theme_id)
        
        # Don't allow deactivation of default themes
        if theme.is_default:
            return jsonify({'error': 'Cannot deactivate default theme'}), 400
        
        theme.is_active = False
        theme.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'message': 'Theme deactivated successfully'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes/<int:theme_id>/rate', methods=['POST'])
@auth_required
def rate_theme(user, theme_id):
    """Rate a theme"""
    try:
        theme = CustomTheme.query.get_or_404(theme_id)
        
        data = request.get_json()
        rating = data.get('rating')
        
        if not rating or not isinstance(rating, (int, float)) or rating < 1 or rating > 5:
            return jsonify({'error': 'Invalid rating. Must be between 1 and 5'}), 400
        
        # For simplicity, we'll just update the average rating
        # In a real application, you'd want to track individual ratings
        if theme.rating is None:
            theme.rating = rating
        else:
            # Simple average calculation (in reality, you'd want to store all ratings)
            theme.rating = (theme.rating + rating) / 2
        
        theme.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({
            'message': 'Theme rated successfully',
            'rating': theme.rating
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes/search', methods=['GET'])
def search_themes():
    """Search themes by name, author, or type"""
    try:
        query = request.args.get('q', '')
        theme_type = request.args.get('type', '')
        author = request.args.get('author', '')
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 10))
        
        # Build query
        themes_query = CustomTheme.query.filter_by(is_active=True)
        
        if query:
            themes_query = themes_query.filter(
                CustomTheme.name.ilike(f'%{query}%') |
                CustomTheme.description.ilike(f'%{query}%')
            )
        
        if theme_type:
            themes_query = themes_query.filter_by(type=theme_type)
        
        if author:
            themes_query = themes_query.filter(CustomTheme.author.ilike(f'%{author}%'))
        
        # Paginate
        themes = themes_query.paginate(
            page=page,
            per_page=per_page,
            error_out=False
        )
        
        theme_list = []
        for theme in themes.items:
            theme_data = {
                'id': theme.id,
                'name': theme.name,
                'theme_id': theme.theme_id,
                'description': theme.description,
                'author': theme.author,
                'version': theme.version,
                'type': theme.type,
                'preview_colors': json.loads(theme.preview_colors) if theme.preview_colors else None,
                'download_count': theme.download_count,
                'rating': theme.rating,
                'created_at': theme.created_at.isoformat()
            }
            theme_list.append(theme_data)
        
        return jsonify({
            'themes': theme_list,
            'total': themes.total,
            'pages': themes.pages,
            'current_page': themes.page,
            'per_page': themes.per_page,
            'has_next': themes.has_next,
            'has_prev': themes.has_prev
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes/my-themes', methods=['GET'])
@auth_required
def get_my_themes(user):
    """Get themes created by the current user"""
    try:
        themes = CustomTheme.query.filter_by(creator_id=user.id, is_active=True).all()
        
        theme_list = []
        for theme in themes:
            theme_data = {
                'id': theme.id,
                'name': theme.name,
                'theme_id': theme.theme_id,
                'description': theme.description,
                'author': theme.author,
                'version': theme.version,
                'type': theme.type,
                'is_public': theme.is_public,
                'preview_colors': json.loads(theme.preview_colors) if theme.preview_colors else None,
                'download_count': theme.download_count,
                'rating': theme.rating,
                'created_at': theme.created_at.isoformat(),
                'updated_at': theme.updated_at.isoformat()
            }
            theme_list.append(theme_data)
        
        return jsonify({
            'themes': theme_list,
            'total': len(theme_list)
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes/export/<int:theme_id>', methods=['GET'])
def export_theme(theme_id):
    """Export theme as JSON file"""
    try:
        theme = CustomTheme.query.get_or_404(theme_id)
        
        if not theme.is_active:
            return jsonify({'error': 'Theme not found'}), 404
        
        # Return theme data as JSON
        theme_data = json.loads(theme.theme_data)
        
        return jsonify({
            'theme': theme_data,
            'export_info': {
                'exported_at': datetime.utcnow().isoformat(),
                'exported_from': 'Pebdeq Theme System',
                'original_author': theme.author,
                'version': theme.version
            }
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes/import', methods=['POST'])
@auth_required
def import_theme(user):
    """Import theme from JSON data"""
    try:
        data = request.get_json()
        
        if not data or 'theme' not in data:
            return jsonify({'error': 'Invalid import data'}), 400
        
        theme_data = data['theme']
        
        # Validate theme data
        errors = validate_theme_data(theme_data)
        if errors:
            return jsonify({'error': 'Validation failed', 'errors': errors}), 400
        
        # Generate unique theme ID if it already exists
        original_id = theme_data['id']
        unique_id = original_id
        counter = 1
        
        while CustomTheme.query.filter_by(theme_id=unique_id).first():
            unique_id = f"{original_id}-{counter}"
            counter += 1
        
        theme_data['id'] = unique_id
        
        # Create preview colors
        preview_colors = {
            'primary': theme_data['colors'].get('primary', '#007bff'),
            'secondary': theme_data['colors'].get('secondary', '#6c757d'),
            'background': theme_data['colors'].get('backgroundPrimary', '#ffffff'),
            'text': theme_data['colors'].get('textPrimary', '#212529'),
            'accent': theme_data['colors'].get('success', '#28a745')
        }
        
        # Create imported theme
        theme = CustomTheme(
            name=f"{theme_data['name']} (Imported)",
            theme_id=unique_id,
            description=theme_data.get('description', ''),
            author=theme_data.get('author', 'Unknown'),
            version=theme_data.get('version', '1.0.0'),
            type=theme_data.get('type', 'light'),
            theme_data=json.dumps(theme_data),
            css_content='',  # Will be generated on first use
            preview_colors=json.dumps(preview_colors),
            creator_id=user.id,
            is_public=False,  # Imported themes are private by default
            is_active=True
        )
        
        db.session.add(theme)
        db.session.commit()
        
        return jsonify({
            'message': 'Theme imported successfully',
            'theme': {
                'id': theme.id,
                'name': theme.name,
                'theme_id': theme.theme_id,
                'description': theme.description,
                'author': theme.author,
                'version': theme.version,
                'type': theme.type,
                'preview_colors': preview_colors,
                'created_at': theme.created_at.isoformat()
            }
        }), 201
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@themes_bp.route('/themes/popular', methods=['GET'])
def get_popular_themes():
    """Get popular themes sorted by download count and rating"""
    try:
        limit = int(request.args.get('limit', 10))
        
        themes = CustomTheme.query.filter_by(is_active=True, is_public=True)\
            .order_by(CustomTheme.download_count.desc(), CustomTheme.rating.desc())\
            .limit(limit).all()
        
        theme_list = []
        for theme in themes:
            theme_data = {
                'id': theme.id,
                'name': theme.name,
                'theme_id': theme.theme_id,
                'description': theme.description,
                'author': theme.author,
                'version': theme.version,
                'type': theme.type,
                'preview_colors': json.loads(theme.preview_colors) if theme.preview_colors else None,
                'download_count': theme.download_count,
                'rating': theme.rating,
                'created_at': theme.created_at.isoformat()
            }
            theme_list.append(theme_data)
        
        return jsonify({
            'themes': theme_list,
            'total': len(theme_list)
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500 